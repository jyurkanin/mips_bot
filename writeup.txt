/*
 * Bad Idea. It was doing way too many switch_modes and wasting tons of paint.
 *
 
if(we are on our own tile){
      set sprint
}
else{ //tile is empty
      set paint
}
*/


if(got target){
       path to target
}

if(paint > 0){ //we have enough paint
         if(not on top of your own square){
               set_paint_mode
         }
}
else {
     request puzzle
     if(!got_target){
        set velocity to zero
     }   
}

if(time since last map update > 128){
        get new powerup map
        get closest powerup
        set target closest powerup

        get new arena map
}





//Bug Pathing. Turn right to get around things.
//bot velocity is either 0 or BOT_VELOCITY, a constant
void path_to_target(int tx , int ty){
     [pix_x, pix_y] = get_robot_position();
     x = (10*x) + 5
     y = (10*y) + 5
     
     theta = atan(x - pix_x, y - pix_y);
     
     do{
         next_pix_x = pix_x + BOT_VELOCITY*cos(theta)
         next_pix_y = pix_y + BOT_VELOCITY*sin(theta);
         tile_x = next_pix_x / 10;
         tile_y = next_pix_y / 10;

         if((arena[tile_x][tile_y] & 0x00FF)){
             theta += 30 //try a bunch of values.
             continue
         }
         else break
     } while(1)
     set_angle_control_absolute();
     set_angle(theta)
}


float cos(float t){
      return 1 - (x^2 / 2) + (x^4 / 24);
}

float sin(float t){
      return x - (x^3 / 6) + (x^5 / 120);
}     
